from termcolor import colored
from queue import Queue
from typing import Any, Dict, Callable
from concurrent.futures import Future

from synapse.pipeline.streamers.common import InterruptCascadeStreamer
from synapse.utils import GLOBAL_THREAD_POOL, AI_SPEECH_END_TOKEN

class AITranscriptIterator(InterruptCascadeStreamer):
    """
    Processes the AI generated transcripts generated by the ChatBot
    """
    thread_pool = GLOBAL_THREAD_POOL
    
    def __init__(self) -> None:
        super(AITranscriptIterator, self).__init__()

        self.words_queue = Queue()
        self.is_closed = False
        
        self.speech_end = True
        self.speech_end_sent = True
        
    def __call__(self, data: str):
        return self._handle_ai_words(data)
        
    def handle_start(self):
        print(colored(f"((AI Speech started))", "light_cyan"), end='')
        self.speech_end = False
        super(AITranscriptIterator, self).handle_start()
                
    def _handle_ai_words(self, words):
        self.words_queue.put(words)
            
    def handle_end(self):
        print(colored(f"((AI Speech ended))", "light_cyan"), end='')
        self.speech_end = True
        super(AITranscriptIterator, self).handle_end()
        
    def __iter__(self):
        return self
    
    def __next__(self) -> str:
        """
        Returns next_word
        """
        if self.is_closed:# or (self.words_queue.empty() and self.speech_end):
            print(colored(f"((AITranscriptIterator closed))", "light_cyan"), end='')
            raise StopIteration
        if self.words_queue.empty() and self.speech_end and not self.speech_end_sent:
            print(colored(f"((AI SPEECH END TOKEN))", "light_cyan"), end='')
            self.speech_end_sent = True     # Set the flag so that the token is sent only once
            return AI_SPEECH_END_TOKEN
        
        self.speech_end_sent = False    # Reset the flag
        
        words = [self.words_queue.get()]
        self.words_queue.task_done()
        # Accumulate words until the queue is empty
        while not self.words_queue.empty():
            word = self.words_queue.get()
            words.append(word)
            self.words_queue.task_done()
        
        return ' '.join(words)
        
    def close(self):
        super(AITranscriptIterator, self).close()
        self.is_closed = True
        
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.close()